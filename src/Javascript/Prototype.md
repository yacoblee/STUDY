# Prototype(프로토타입)

## Prototype?

자바스크립트에는 **클래스**라는 개념이 없다. 그래서 **객체**를 복사하여 **새로운 객체**를 생성하는 **프로토타입**기반의 언어이다.

여기서 **프로토타입**이란? 원래 형태, 즉 표준 형태를 말한다. 

그러면 **프로토타입 기반의 언어란?** 원래 형태를 이용하여 **새로운 객체**를 만드는 것이다. 

또 이렇게 생성된 객체는 또 다른 객체의 **원형**이 될 수 있다. 

프로토 타입은 객체를 확장하고, 객체지향적인 프로그래밍을 할 수 있게 해준다. 

여기서 프로토타입은 **두 가지**로 나뉜다. 하나는 **프로토타입 속성**과 **프로토링크**이다. 


<br>



## constructor

계속 똑같은 리스트를 만들어야 한다면 그 개수만큼 작성을해주어야 하지만 편리한 방법으로는 오브젝트를 **복사**하는 방법이다.

```js

function 복사기() {
  this.name="연주"
  this.age="20"
}

//만약 영어로 짓는다면 앞 글자는 대문자로! 일반함수와는 다르다! 

```

이런식으로 **function**함수 키워드를 이용하여 **object 생성 기계**를 만들 수 있다. 

이 복사기를 만드는 순간 **constructor**가 생성된다.

또 복사기()안에서 사용한 **this**는 복사기로부터 새로 생성되는 **object**를 의미한다. **(또는 인스턴스라고 한다.)** 


그럼 이제 object를 복사해보자. 

```js 

const 복사 = new 복사기();
```

이렇게 작성해주면 복사기로부터 오브젝트가 복사된다.  <br>


![4](https://user-images.githubusercontent.com/68775082/143888277-ca094403-9f71-4616-9075-78a610466b7b.PNG) <br>

여기서 나오는 **복사기**는 이 오브젝트를 만든 contructor이름이다! 

그리고 복사기에는 **함수**도 추가할 수 있다.



```js

function 복사기() {
  this.name="연주"
  this.age="20"
  this.sayHi= function() {
    console.log("hi")
  }
}

const 복사 = new 복사기();

console.log(복사.sayHi())


///hi

```

<br>


## 프로토타입을 사용해서 상속기능 만들기 

```js

function 복사기() {
  this.name="연주"
  this.age="20"
  this.sayHi= function() {
    console.log("hi")
  }
}

const 복사 = new 복사기();

```
<br>


여기서 **복사**가 **복사기**의 속성들을 **상속**받았다고 한다. (부모와 자식관계)

그럼 **프로토타입은?** 위와 같이 **복사기(constructor)** 를 만들면 프로토타입이라는 **공간**이 자동으로 생긴다.

아래를 확인해보자. <br>

![5](https://user-images.githubusercontent.com/68775082/143890969-f2f5efe4-2661-4e60-85e2-7975feff8196.PNG)


<br>


또 프로토타입은 부모가 가지고 있는 **유전자**라고 생각하면 되는데 **부모**에 값을 추가하면 모든 자식들이 물려받을 수 있다. 


```js

function 복사기() {
  this.name="연주"
  this.age="20"
  this.sayHi= function() {
    console.log("hi")
  }
}
복사기.prototype.mbti = "intp"  ///유전자 추가

```

> 결과 <br>


![6](https://user-images.githubusercontent.com/68775082/143891879-71002e7c-f09b-4b76-af07-ef3e73036b17.PNG)

직접적으로 **복사**에는 추가하지 않았던 mbti가 접근하면 값이 나온다. 

<br>

## prototype의 동작원리는?

위와 같은 예시에서 **복사**는 mbti의 값을 찾는다. 그리고 없다면 자신이 상속한 **부모**에서 mbti의 값을 찾는다. 

그리고 존재한다면 실행한다. 이러한 순서로 자료를 출력한다. 

결과적으로 부모에 값을 추가하면 **자식**이 쓸 수 있다. 

그렇다면 

`복사.age.toString()` 과 같은 내장함수는 어떻게 사용할 수 있을까???? 

복사에도 없고 복사기에도 없으면 그 부모의 유전자를 찾고 없다면 그 부모의 부모의 유전자를 찾는다. 

거기서 찾은 유전자에 존재하는 함수를 사용한다. 

<br>


예제)

```js

const 어레이 = [1,2,3];

const 어레이 = new Array(1,2,3);

```

위와 아래와 같은 표현방식이다. 첫번째 줄과 같이 작성은하지만 실제로는 두번째 줄과 같이 만들어진다.

그리고 Array(부모)가 가지고 있는 기본함수를 **어레이가 상속**하게되어 아래와 같이 사용할 수 있게된다. 

```js
어레이.sort();
어레이.map();
어레이.push();
```

<br>


array 말고도 object도 마찬가지이다

```js

const obj = {name : kim}

const objt = new Object() 

```

모든 object 자료형은 **object 부모**를 이용하여 만들어진다. 즉 object의 기본함수(Object.prototyep)를 상속하여 사용할 수 있다. <br>


## 프로토타입의 특징

프로토타입은 함수에서만 생성된다. 자식에서 프로토타입을 확인하고 싶다면? `자식.__proto__`으로 가능하다.

그러면 부모의 유전자가 어떤지 확인할 수 있다. 또 `__proto__`를 이용해 프로토타입을 갖고 있지 않은 부모에 자식을 등록시킬 수 있다.

<br>


예제)

```js

const 부모 = { name : "kim"}
comst 자식 = {}

자식.__proto__ = 부모;  //으로 작성 가능 

```


